# 스택

## 📝 문제 요약
너비가 1이고, 높이가 다양한 히스토그램이 주어진다.

이 히스토그램에서 만들 수 있는 가장 큰 직사각형의 넓이를 구하라.

입력: 첫 번째 수는 직사각형의 개수 N, 그 뒤에 N개의 높이가 주어짐.

출력: 가장 넓은 직사각형의 넓이.

입력은 여러 줄에 걸쳐 주어지며, 0이 입력되면 종료.

## 🤔 헷갈렸던 점 / 몰랐던 점
 - **헷갈린 점**:

"현재 막대보다 큰 막대들은 이제 끝났으므로 pop"이라는 개념이 처음에는 이해되지 않았다.

startIndex를 갱신하며 누적되는 인덱스 개념이 직관적이지 않아 헷갈림.

가장 작은 막대가 전체를 커버하는 경우가 뒤늦게 stack 후처리로 계산된다는 것을 놓침.

 - **몰랐던 점**:

스택을 사용해 오름차순을 유지하면서, 현재 높이보다 낮아지면 pop하며 직사각형 넓이를 갱신해야 한다는 점.

최종적으로 stack에 남은 요소들도 모두 꺼내어 계산해야 최댓값이 나오는 경우를 놓칠 수 있음.

## ✂️ 간략화 코드

```cs
using System;
using System.Text;
using System.Collections.Generic;

namespace Boj
{
    class Program
    {
        static void Main(string[] args)
        {
            StringBuilder sb = new StringBuilder();

            while(true)
            {
                int[] input = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);
                int rect = input[0];
                if(rect == 0)
                    break;

                int[] height = new int[rect];
                Array.Copy(input, 1, height, 0, rect);

                Stack<(int height, int index)> stack = new Stack<(int, int)>();
                long maxArea = 0;

                for (int i = 0; i < rect; i++)
                {
                    int startIndex = i;

                    while(stack.Count > 0 && stack.Peek().height > height[i])
                    {
                        var (h, idx) = stack.Pop();
                        long width = i - idx;
                        long area = (long)h * width;
                        maxArea = Math.Max(maxArea, area);
                        startIndex = idx;
                    }

                    stack.Push((height[i], startIndex));
                }

                while (stack.Count > 0)
                {
                    var (h, idx) = stack.Pop();
                    long width = rect - idx;
                    long area = (long)h * width;
                    maxArea = Math.Max(maxArea, area);
                }

                sb.AppendLine(maxArea.ToString());
            }

            Console.Write(sb);
        }
    }
}
```

## 🔍 간략화 포인트
오름차순 스택 유지: 스택에 높이를 오름차순으로 유지하며 push

작은 막대 등장 시: 이전 막대가 현재보다 높다면, 더 이상 확장 불가 → pop하며 넓이 계산

시작 인덱스 추적: pop한 막대의 인덱스를 startIndex로 업데이트하여 너비 계산에 사용

스택 후처리: 모든 입력을 순회한 뒤 남은 높이들도 직사각형 넓이로 계산

StringBuilder 사용: 반복 출력의 성능 최적화

